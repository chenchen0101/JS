# Vue相关
### 1. 怎样理解 Vue 的单向数据流？
**父子组件之间怎么传值？**


### 2. 谈谈你对 Vue 组件生命周期的理解？

**Vue组件的生命周期有哪些？ 它们的作用分别是什么？**

**我们在组件渲染最初的时刻进行网络请求会放在哪个生命周期函数里？**

**在什么样的生命周期阶段之后，我们才能过访问Dom?**

### 3. Vue 组件间通信有哪几种方式？

> Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信。
参考文章： 

[Vue 组件间通信有哪几种方式？](https://juejin.cn/post/6844903918753808398#heading-15)

### 4. 你了解过 Vue 的虚拟DOM吗？
**虚拟DOM是什么东西？**
**他的优缺点是什么？？**
参考文章： 

[虚拟 DOM 的优缺点？](https://juejin.cn/post/6844903918753808398#heading-25) 

[深入剖析：Vue核心之虚拟DOM](https://juejin.cn/post/6844903895467032589)

### 4. 你听说过SSR吗？

我们如何使用ssr来优化页面？使用ssr和不使用ssr的页面有什么不一样的地方？

参考文章： [浅谈服务端渲染(SSR) - 简书 (jianshu.com)](https://www.jianshu.com/p/10b6074d772c)

[渲染篇一：服务端渲染（SSR） - 简书 (jianshu.com)](https://www.jianshu.com/p/b8cfa496b7ec)

**SSR：**SSR模式下，当用户首次请求页面时，服务器把需要的组件或页面渲染成HTML字符串，返回给客户端，客户端只负责解析HTML

**为什么使用服务端渲染，优点：**

1、首屏加载块：相比于加载单页应用，我只需加载当前页面的内容，而不需要像react或vue一样加载全部的js文件

2、SEO优化：对于单页应用，搜索引擎并不能收录到ajax爬取数据之后再动态js渲染出来的页面

**利弊**：

优：首屏渲染块、利于SEO、可以生成缓存片段，生成静态化文件、节能

缺点：用户体验较差，不容易维护，通常前端改了部分html或css，后端也要修改。

### 6. vue-route的原理是什么(前端路由实现原理)？

参考文章：[浅谈前端路由 - 简书 (jianshu.com)](https://www.jianshu.com/p/d2aa8fb951e4)

vue-router有hash和history两种模式。

==hash==：vue-router中hash模式的实现原理就是通过监听hash值的变化，重新渲染页面。location.hash用于获取hash的值。也就是url中#后面的内容

```js
//location.hash='#me':
https://www.srtian.com#me
```

我们使用hashchange事件监听hash的变化。有两种方式改变hash的值：

1、通过a标签的href属性，当用户点击标签时，url就会发生改变，也就会触发hashchange事件：

```js
<a href="#srtian">srtian</a>
```

2、通过js对location.hash进行赋值，改变url，触发hash事件

```js
location.hash="#srtian"
```

**hash模式的特性：**

1、当hash改变时页面不会重新刷新。

2、hash值每改变一次都会在访问历史中增加一个记录。因此可通过浏览器的前进后退按钮控制hash的切换。

==History API==:通过History API来操作路由的变化。history.pushState()新增历史记录，history.ReplceState()替换历史记录，这两个api在不刷新页面的情况下，切换哪个路由，就渲染哪个组件。此外，还使用popstate事件来监听历史记录的变化。

**两种实现方式的对比**：基于hash的路由实现，兼容性更好。基于history API的更美观，但需要对服务器做些修改，需要对不同的路由进行相应的设置。



### 7、怎样实现路由懒加载

项目实践：由于用静态路由导入路由的方式访问首页时会使首页加载速度变慢（所有路由对应的页面都会被加载）。所以采用动态路由（路由懒加载）的方式进行优化。

实现：首先将所有的路由都使用动态路由导入,`然后通过Webpack编译打包后，会把每个路由组件的代码分割成一一个js文件，初始化时不会加载这些js文件，只有加载该路由时，才会加载该文件`。（若想把某个路由下的所有组件都打包在同个异步块，只需添加一个特殊的语法注释来提供chunk name）

灰体部分也是懒加载能做到性能优化的原因